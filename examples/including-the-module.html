<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Including Browzium Engine example</title>
</head>

<body>
    <canvas></canvas>
    <input type="range" id="slider" min="30" max="120" value="90" step="1">
    <div id="fovDisplay">FOV: 90</div>

    <input type="range" id="compressionSlider" min="0.5" max="10" value="1" step="0.25">
    <div id="compressionDisplay">Compression rate: 1</div>

    <p id="frame_time">average frame time: %s</p>
    <p id="frames_per_second">frames per second: %s</p>
</body>

<style>
    canvas {
        width: 80vw;
        height: 80vh;
        display: block;
    }

    h1,
    h2,
    h3,
    p,
    #fovDisplay,
    #frame_time,
    #frames_per_second,
    #compressionDisplay {
        color: #ffffff;
    }

    a {
        color: #bb86fc;
    }

    #slider,
    .container {
        background-color: #333;
    }

    button,
    .btn {
        background-color: #4d4d4d;
        color: #ffffff;
    }

    body {
        background-color: #1a1a1a;
        color: #ffffff;
    }
</style>

<script type="module">
    import Engine from "../dist/bundle.js"
    import { Vector3, Triangle } from "../dist/bundle.js"
    import { OBJParser } from "../dist/bundle.js"

    /*
        For real use, remove ../dist/bundle.js and instead use

        https://cdn.jsdelivr.net/gh/JijaProGamer/Browzium-Engine/dist/bundle.js
    */

    const shaderSource = await (await fetch("../src/core/shaders/compute.wgsl")).text();

    const frame_time_ui = document.querySelector(`#frame_time`)
    const frames_per_second_ui = document.querySelector(`#frames_per_second`)

    const fov_slider = document.getElementById("slider");
    const fov_display = document.getElementById("fovDisplay");

    const compression_slider = document.getElementById("compressionSlider")
    const compression_display = document.getElementById("compressionDisplay")

    const canvas = document.getElementsByTagName("canvas")[0];

    let GameEngine = new Engine({
        renderer: {
            canvas,
            shader: shaderSource,
        }
    })

    await GameEngine.AwaitPageActivation()
    await GameEngine.InitActivation()

    let frames = 0;
    let frameTime = 0;

    GameEngine.Camera.SetFOV(90)
    fov_slider.addEventListener("input", () => {
        fov_display.textContent = `FOV: ${slider.value}`
        GameEngine.Camera.SetFOV(slider.value)
    });

    let lastAsked = performance.now() - 1000
    canvas.addEventListener("click", async () => {
        if (!document.pointerLockElement && (performance.now() - lastAsked) >= 1500) {
            await canvas.requestPointerLock({
                unadjustedMovement: true,
            });
        }
    });

    let screenCompression = compression_slider.value;
    let screenHeight;
    let screenWidth;

    compression_slider.addEventListener("input", () => {
        compression_display.textContent = `Compression rate: ${compression_slider.value}`
        screenCompression = compression_slider.value
        setCanvasSize(screenHeight, screenWidth)
    });

    function setCanvasSize(height, width) {
        screenHeight = height;
        screenWidth = width;

        canvas.height = height / screenCompression;
        canvas.width = width / screenCompression;

        canvas.style.width = width;
        canvas.style.height = height;
    }

    setCanvasSize(80 / 100 * screen.height, 80 / 100 * screen.width)

    // Camera rotation

    let PPI = 400;
    let cameraRotation = new Vector3(0, 0, 0);
    let rotationX = 0;
    let rotationY = 0;
    let rotationZ = 0;

    GameEngine.Camera.SetOrientation(new Vector3(0.1, 0.1, -1))

    function updateOrientation(e) {
        rotationX -= (e.movementX / PPI)
        rotationY += (e.movementY / PPI)

        rotationX = Math.max(-1, Math.min(rotationX, 1))
        rotationY = Math.max(-1, Math.min(rotationY, 1))
        rotationZ = rotationX

        //cameraRotation.x = 0
        cameraRotation.x = rotationX
        cameraRotation.y = rotationY
        cameraRotation.z = -1
        //cameraRotation.z = rotationZ

        GameEngine.Camera.SetOrientation(cameraRotation)
    }

    // Camera position

    let cameraPosition = new Vector3(0, 5, -2);
    
    let cameraSpeed = 0.05;
    let moveModes = { up: false, down: false, right: false, left: false, forward: false, back: false }

    GameEngine.Camera.SetPosition(cameraPosition)

    function MoveCameraPosition() {
        let moveDirection = new Vector3(0, 0, 0)
        let right = new Vector3(0, 0, -1).cross(cameraRotation).normalize();
        right.y = 0;

        if (moveModes.up) {
            moveDirection.add(new Vector3(0, 1 * cameraSpeed, 0));
        }

        if (moveModes.down) {
            moveDirection.add(new Vector3(0, -1 * cameraSpeed, 0));
        }

        if (moveModes.right) {
            moveDirection.add(right.copy().multiplyScalar(cameraSpeed));
        }

        if (moveModes.left) {
            moveDirection.add(right.copy().multiplyScalar(-cameraSpeed));
        }

        if (moveModes.forward) {
            moveDirection.add(cameraRotation.copy().multiplyScalar(-cameraSpeed));
        }

        if (moveModes.back) {
            moveDirection.add(cameraRotation.copy().multiplyScalar(cameraSpeed));
        }

        cameraPosition.add(moveDirection)

        if (moveDirection.lengthSquared() > 0)
            GameEngine.Camera.SetPosition(cameraPosition)
    }

    document.addEventListener('keydown', (event) => {
        switch (event.key) {
            case 'w':
                moveModes.forward = true
                break;
            case 'a':
                moveModes.left = true
                break;
            case 's':
                moveModes.back = true
                break;
            case 'd':
                moveModes.right = true
                break;
            case 'q':
                moveModes.down = true
                break;
            case 'e':
                moveModes.up = true
                break;
        }
    });

    document.addEventListener('keyup', (event) => {
        switch (event.key) {
            case 'w':
                moveModes.forward = false
                break;
            case 'a':
                moveModes.left = false
                break;
            case 's':
                moveModes.back = false
                break;
            case 'd':
                moveModes.right = false
                break;
            case 'q':
                moveModes.down = false
                break;
            case 'e':
                moveModes.up = false
                break;
        }
    });

    // Other stuff

    let active = false;

    document.addEventListener('keydown', function (event) {
        if (event.key === 'o') {
            active = !active

            if (active) {
                setCanvasSize(screen.height, screen.width)


                if (canvas.requestFullscreen) {
                    canvas.requestFullscreen();
                }
            } else {
                setCanvasSize(80 / 100 * screen.height, 80 / 100 * screen.width)
            }
        }
    });

    document.addEventListener("pointerlockchange", () => {
        lastAsked = performance.now()

        if (document.pointerLockElement === canvas) {
            document.addEventListener("mousemove", updateOrientation, false);
        } else {
            document.removeEventListener("mousemove", updateOrientation, false);

            setCanvasSize(80 / 100 * screen.height, 80 / 100 * screen.width)
        }
    }, false);

    let oldTime = performance.now()
    async function render() {
        if (frames > 1) {
            //return
        }

        //console.log("Rendering")
        let frameDelta = await GameEngine.RenderFrame()
        let delta = performance.now() - oldTime
        oldTime = performance.now()

        frames++;
        frameTime += delta;

        if (frameTime > 1000) {
            frames_per_second_ui.innerHTML = `frames per second: ${(1000 / (frameTime / frames)).toFixed(2)}`;
            frame_time_ui.innerHTML = `average frame time: ${(frameTime / frames).toFixed(2)}`;

            frames = 0;
            frameTime = 0;
        }

        requestAnimationFrame(render)
    }

    requestAnimationFrame(render)

    setInterval(() => {
        MoveCameraPosition()
        GameEngine.StepFrame()
    }, 1000 / 50)

    // Scene stuff

    let cornellBox = OBJParser(await (await fetch("./cornellBox.obj")).text(), {
        "cornellBox": await (await fetch("./cornellBox.mtl")).text()
    })

    await GameEngine.Renderer.SetMaterials(cornellBox.materials)
    await GameEngine.Renderer.SetTriangles(cornellBox.triangles)

    /*let triangle1 = new Triangle()
    triangle1.a = new Vector3(-1.0, -1.0, 5.0)
    triangle1.b = new Vector3(1.0, -1.0, 5.0)
    triangle1.c = new Vector3(0.0, 1.0, 5.0)

    let triangle2 = new Triangle()
    triangle2.a = new Vector3(-3.0, -5.0, 3.0),
    triangle2.b = new Vector3(0.0, -5.0, -3.0),
    triangle2.c = new Vector3(3.0, -5.0, 3.0),

    await GameEngine.Renderer.SetTriangles([triangle1, triangle2])*/

    /*const sampleRate = GameEngine.Audio.audioContext.sampleRate;
    const duration = 1; // Duration of the rocket launch
    const startFrequency = 500; // Initial frequency
    const endFrequency = 2000; // Final frequency
    const numSamples = Math.floor(sampleRate * duration);
    const audioBuffer = GameEngine.Audio.CreateAudioBuffer(numSamples, 1);
    const channelData = audioBuffer.getChannelData(0);

    for (let i = 0; i < numSamples; i++) {
        const t = i / sampleRate;

        const currentFrequency = startFrequency + (endFrequency - startFrequency) * (i / numSamples);
        const amplitude = 0.3 * Math.exp(-2 * (i / numSamples - 0.75) ** 2);

        channelData[i] = amplitude * Math.sin(2 * Math.PI * currentFrequency * t);
    }

    await GameEngine.Audio.PlaySound(audioBuffer, [0, 0, -1], [0, 1, 1])*/
</script>

</html>