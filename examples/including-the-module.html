<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Including Browzium Engine example</title>
</head>

<body>
    <canvas></canvas>
    <input type="range" id="slider" min="30" max="120" value="90" step="1">
    <div id="fovDisplay">FOV: 90</div>

    <p id="frame_time">average frame time: %s</p>
    <p id="frames_per_second">frames per second: %s</p>
</body>

<style>
    canvas {
        width: 80vw;
        height: 80vh;
        display: block;
    }
</style>

<script type="module">
    import Engine from "../dist/bundle.js"
    /*
        For real use, remove ../dist/bundle.js and instead use

        https://cdn.jsdelivr.net/gh/JijaProGamer/Browzium-Engine/dist/bundle.js
    */

    const computeShaderSource = await (await fetch("../src/core/shaders/compute.wgsl")).text();

    const frame_time_ui = document.querySelector(`#frame_time`)
    const frames_per_second_ui = document.querySelector(`#frames_per_second`)

    const fov_slider = document.getElementById("slider");
    const fov_display = document.getElementById("fovDisplay");

    const canvas = document.getElementsByTagName("canvas")[0];

    let GameEngine = new Engine({
        renderer: {
            canvas,
            fov: 90,
            shaders: {
                compute: computeShaderSource
            },
        }
    })

    await GameEngine.AwaitPageActivation()
    await GameEngine.InitActivation()

    let frames = 0;
    let frameTime = 0;

    fov_slider.addEventListener("input", () => {
        fov_display.textContent = `FOV: ${slider.value}`
        GameEngine.RenderingManager.SetFOV(slider.value)
    });

    let lastAsked = performance.now() - 1000
    canvas.addEventListener("click", async () => {
        if (!document.pointerLockElement && (performance.now() - lastAsked) >= 1500) {
            await canvas.requestPointerLock({
                unadjustedMovement: true,
            });
        }
    });

    let PPI = 250;
    let rotationX = 0;
    let rotationY = 0;

    function updatePosition(e) {
        let movementX = e.movementX / PPI;
        let movementY = e.movementY / PPI;

        rotationX = (rotationX + movementX) % 2;
        rotationY = (rotationY + movementY) % 2;

        if (rotationX < -1) rotationX = -1;
        if (rotationX > 1) rotationX = 1;
        if (rotationY < -1) rotationY = -1;
        if (rotationY > 1) rotationY = 1;

        let length = Math.sqrt(rotationX * rotationX + rotationY * rotationY)
        GameEngine.RenderingManager.SetCameraRotation([-rotationX / length, 0, -rotationY / length])
    }

    document.addEventListener("pointerlockchange", () => {
        lastAsked = performance.now()
        
        if (document.pointerLockElement === canvas) {
            document.addEventListener("mousemove", updatePosition, false);
        } else {
            document.removeEventListener("mousemove", updatePosition, false);
        }
    }, false);

    async function render() {
        if (frames > 1) {
            //return
        }

        //console.log("Rendering")
        let delta = await GameEngine.RenderFrame()

        frames++;
        frameTime += delta;

        if (frameTime > 1000) {
            frames_per_second_ui.innerHTML = `frames per second: ${(1000 / (frameTime / frames)).toFixed(2)}`;
            frame_time_ui.innerHTML = `average frame time: ${(frameTime / frames).toFixed(2)}`;

            frames = 0;
            frameTime = 0;
        }

        requestAnimationFrame(render)
    }

    requestAnimationFrame(render)

    setInterval(() => {
        GameEngine.StepFrame()
    }, 1000 / 50)

    const sampleRate = GameEngine.AudioManager.audioContext.sampleRate;
    const duration = 1; // Duration of the rocket launch
    const startFrequency = 500; // Initial frequency
    const endFrequency = 2000; // Final frequency
    const numSamples = Math.floor(sampleRate * duration);
    const audioBuffer = GameEngine.AudioManager.CreateAudioBuffer(numSamples, 1);
    const channelData = audioBuffer.getChannelData(0);

    for (let i = 0; i < numSamples; i++) {
        const t = i / sampleRate;

        const currentFrequency = startFrequency + (endFrequency - startFrequency) * (i / numSamples);
        const amplitude = 0.3 * Math.exp(-2 * (i / numSamples - 0.75) ** 2);

        channelData[i] = amplitude * Math.sin(2 * Math.PI * currentFrequency * t);
    }

    await GameEngine.AudioManager.PlaySound(audioBuffer, [0, 0, -1], [0, 1, 1])
</script>

</html>